use std::sync::atomic::{AtomicBool, Ordering};

use dcl_rpc::{
    server::RpcServer,
    transports::{TransportError, TransportEvent},
};
use futures_util::{
    stream::{SplitSink, SplitStream},
    SinkExt, StreamExt,
};
use tokio::{join, sync::Mutex};
use warp::{
    reject,
    ws::{Message as WarpWSMessage, WebSocket},
    Filter,
};

include!(concat!(env!("OUT_DIR"), "/_.rs"));
struct RpcContext {}

pub async fn init_app() {
    let rpc_ctx = RpcContext {};

    // first create rpc server
    let mut rpc_server: RpcServer<RpcContext, WarpWebSocketTransport> =
        dcl_rpc::server::RpcServer::create(rpc_ctx);

    // get the server events sender
    let server_events_sender = rpc_server.get_server_events_sender();

    let routes = warp::path("ws")
        // first middleware or "Filter"
        .and(
            warp::header::<String>("authorization").and_then(|auth| async move {
                // This acts as a middleware. It will reject the connection before upgrading it
                if auth == "123" {
                    Ok(auth)
                } else {
                    Err(reject()) // this reject is a 404
                }
            }),
        )
        // second middleware or "Filter" to check if the connection (or request) wants to be upgraded to have a websocket connection.
        .and(warp::ws())
        // finally we get the connection and we set a callback to send the ws transport to the RpcServer once the connection is finally upgraded.
        .map(move |_auth: String, ws: warp::ws::Ws| {
            let server_events_sender = server_events_sender.clone();
            ws.on_upgrade(|websocket| async move {
                server_events_sender
                    .send_attach_transport(Arc::new(WarpWebSocketTransport::new(websocket)))
                    .unwrap();
            })
        });

    rpc_server.set_handler(|port| BookServiceRegistration::register_service(port, BookService {}));

    let rpc_server_handle = tokio::spawn(async move {
        rpc_server.run().await;
    });

    let http_server_handle = tokio::spawn(async move {
        warp::serve(routes).run(([127, 0, 0, 1], 3030)).await;
    });

    let (_, _) = join!(http_server_handle, rpc_server_handle);
}

type ReadStream = SplitStream<WebSocket>;
type WriteStream = SplitSink<WebSocket, WarpWSMessage>;

pub struct WarpWebSocketTransport {
    read: Mutex<ReadStream>,
    write: Mutex<WriteStream>,
    ready: AtomicBool,
}

impl WarpWebSocketTransport {
    /// Crates a new [`WebSocketTransport`] from a websocket connection generated by [`WebSocketServer`] or [`WebSocketClient`]
    pub fn new(ws: WebSocket) -> Self {
        let (write, read) = ws.split();
        Self {
            read: Mutex::new(read),
            write: Mutex::new(write),
            ready: AtomicBool::new(false),
        }
    }
}

#[async_trait::async_trait]
impl Transport for WarpWebSocketTransport {
    async fn receive(&self) -> Result<TransportEvent, TransportError> {
        match self.read.lock().await.next().await {
            Some(Ok(message)) => {
                if message.is_binary() {
                    let message = self.message_to_transport_event(message.into_bytes());
                    if let TransportEvent::Connect = message {
                        self.ready.store(true, Ordering::SeqCst);
                    }
                    return Ok(message);
                } else {
                    // Ignore messages that are not binary
                    return Err(TransportError::Internal);
                }
            }
            Some(Err(err)) => {
                println!("Failed to receive message {err:?}");
            }
            None => {
                println!("No message")
            }
        }
        println!("Closing transport...");
        self.close().await;
        Ok(TransportEvent::Close)
    }

    async fn send(&self, message: Vec<u8>) -> Result<(), TransportError> {
        let message = WarpWSMessage::binary(message);
        self.write
            .lock()
            .await
            .send(message)
            .await
            .map_err(|_| TransportError::Internal)?;
        Ok(())
    }

    async fn close(&self) {
        match self.write.lock().await.close().await {
            Ok(_) => {
                self.ready.store(false, Ordering::SeqCst);
            }
            _ => {
                println!("Couldn't close tranport")
            }
        }
    }

    fn is_connected(&self) -> bool {
        self.ready.load(Ordering::Relaxed)
    }
}

struct BookService {}

#[async_trait::async_trait]
impl BookServiceServer<RpcContext> for BookService {
    async fn get_book(&self, _request: GetBookRequest, _ctx: Arc<RpcContext>) -> Book {
        Book {
            isbn: 1000,
            title: "Rust For Rustaceans".to_string(),
            author: "Jon".to_string(),
        }
    }
}
